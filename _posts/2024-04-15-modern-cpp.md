---
layout: post
title: "现代 C++"
date: 2024-04-15
last_modified_at: 2024-04-15
categories: [c++]
tags: [c++]
---

* 目录  
{:toc}
<br/>

关于现代 C++ 的书和文章遍地都是，但无论如何，每个人都应该自己归纳总结一下，故有此文。  

所谓现代 C++，指的是从 C++11 开始的 C++，从 C++11 开始，加入一些比较现代的特性，使得用 C++ 开发少了很多心智负担，程序也更加健壮。从 C++11 开始，每 3 年发布一个新版本，到今年（2024）已经有 5 个版本了，分别是 C++11、C++14、C++17、C++20、C++23，这 5 个版本引入了上百个新特性，这些特性使得 C++ “看起来像一门新语言”。   

---

# 新特性

## C++11 新特性

C++11 是一个 major 版本，有不少新特性，有些是有用但不算很重要，个人认为最重要的特性包括：  

* 智能指针: unique_ptr, shared_ptr
* 移动语义
* 新的内存模型
* lambda 表达式
* auto 和 decltype 推导


### 智能指针


### 移动语义


### lambda 表达式

---

## C++14 新特性
C++14 是一个 minor 版本，没什么重要的新特性，主要是在给 C++11 打补丁，为使用者 “带来极大方便”，实现 “对新手更为友好” 这一目标。 

与方便使用相关的特性，就是支持函数返回值推导了，在 C++11 中这么写是编译不过的，在 C++14 中支持了：  
```
auto func(int i) {
    return i;
}
```

---

## C++17 新特性
C++17 是一个 major 版本，

重要的特性包括：  
* 结构化绑定


### 结构化绑定



---

## C++20 新特性
C++20 也是一个 major 版本，有很重要的更新，"The Big Four"，即四个重要的特性，分别是：概念、范围、协程和模块。  

由于平常用 lua 多，所以对于协程这个特性比较关注。C++20 实际上提供的是协程的基础设施，相当原始，是面向库开发者的，普通程序员应该使用基于这些基础开发的各种便于使用的库。比如 C++23 就引入了这样的库，叫 generator。  

我有点不太理解，在 lua 里面，协程挺简单的，到了 C++ 这里，怎么变得那么复杂，以至于人们要写那么冗长的文章来介绍它。  



---

## C++23 新特性

---

# 若干重要概念与坑
可能有多年 c++ 编程经验，但回过头来发现，对于一些基础概念却并不怎么熟悉，比如表达式、语句这些。   

## 表达式 (expression)
表达式是由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式（expression），其结果就是字面值和变量的值。把一个运算符（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式 (expression)。[3]  


## 语句 (statement)
C++语言中的大多数语句都以分号结束，一个表达式，比如 ival + 5，末尾加上分号就变成了表达式语句（expression statement）。表达式语句的作用是执行表达式并丢弃掉求值结果。[3] 

空语句是最简单的语句，空语句中只含有一个单独的分号：`;`。空语句的作用是，如果语法上需要一条语句但逻辑上不需要，此时应该使用空语句，比如：  

```c++
while (cin >> s && s != sought)
    ;
```

复合语句（compound statement）是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作块（block）。复合语句的作用是，如果在程序的某个地方，语法上需要一条件语句，但逻辑上需要多条语句，比如：  

```c++
while (val <= 10) {
    sum += val;
    ++val;
}
```

注意：块不以分号作为结束。  


## 容易搞错的赋值表达式

* 什么是赋值表达式    
`int a = 100` 这是赋值表达式？  
不是的，这是定义时初始化，赋值表达式不能以类型名开头，`a = 100` 这才是赋值表达式。   

* 赋值表达式的结果   
赋值表达式本身是有结果的，它的结果就是 = 号左侧的运算对象，是一个左值。比如 `a = 100`，它的结果就是 a，可以这样验证：   

```c++
int a;
printf("%d\n", (a = 5));    // 输出 5
printf("0x%x\n", &a);       // 在我本机上输出 0x500d58
printf("0x%x\n", &(a=5));   // 在我本机上输出 0x500d58
```

* 赋值表达式的运算顺序   
右结合的，从右到左，所以这样的一个语句：`a = b = c = 5;`，会把 a、b、c 都赋值为 5，它相当于这样：`a = (b = (c = 5))`。     
先是 5 赋值给 c，然后 c = 5 的值是 5，5 赋值给 b，然后 b = 5 的值是 5，5 再赋给 a。    
 


## 函数 (function)
函数是一个**命名了的代码块**，我们通过调用函数执行相应的代码。函数可以有 0 个或多个参数，而且（通常）会产生一个结果。可以重载函数，也就是说，同一个名字可以对应几个不同的函数。[3]     


## 类型转换
TODO

参考：https://weread.qq.com/web/reader/55f32d30813ab6ea1g017832k3c5327902153c59dc0488e1?


## 列表初始化
是 c++11 引入的一种新的初始化方式，使用花括号 {} 来初始化变量，其目的是为了实现一种通用的初始化方式。   

这两个语句 `int c = {100};`，`int c {100};` 在多数时候被编译器同等处理。 

这种初始化形式的一个重要特点：当初始值存在丢失信息的风险时，编译器会报错，比如用 double 初始化 int 变量：`int c {200.45};`。  


## 无参数构造函数的小坑
假设一个类 A，它的构造函数是无参数的，那么要这样写来定义一个实例：`A a;`，不能写成这样：`A a();`，因为后者会被编译器当成是函数声明。  


## 右值引用、移动语义

### 左值与右值
从 c 语言开始就有左值、右值这两个名词，当时的用途也很简单，就是帮助记忆：左值可以位于赋值语句的左侧，而右值不能。  

C++ 的表达式也只有左值和右值，大体也是相似的意思。简单的理解，有地址（内存位置）的对象就是一个左值，比如 `int i = 3`，i 是一个左值，它是有地址的，而 3 是右值，它是个字面值，没有地址。有时候左值可以作为右值，这时候用的是它的值，比如这样：`int i = 3; int j = i;`，当用 i 去初始化 j 的时候，它是作为右值出现的，这时候用的是 i 的值，而不是 i 的地址（内存位置）。  

所以，可以简单的归纳一下：当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值时，用的是对象的地址（内存位置）。[3]  


### 运算符的运算对象和运算结果
* 赋值运算符：运算对象是左值，运算结果也是左值。  

* 取地址符：运算对象是左值，运算结果是右值。  

* 内置解引用运算符、下标运算符、迭代器解引用运算符、string&vector的下标运算符：运算对象是左值，运算结果也是左值。   

* 内置类型和迭代器的递增递减运算符：运算对象是左值，运算结果，前置版本是左值，后置版本是右值。  


解引用运行符就是 * 操作符，用于获得指针所指的对象，比如:   

```c++
int v = 100;
int* p = &v;
*p = 200;
```

p 是一个指向了对象的指针，则 *p 就是获得指针 p 所指的对象，比如 `*p = 100;`     


递增递减的前置和后置版本的具体区别：   
* 前置版本，比如： ++i 返回的是左值，过程是直接把 i 加 1，然后返回 i。     
* 后置版本，比如： i++ 返回的是右值，过程是先用一个临时变量保存 i 的值，然后把 i 值加1，然后返回临时变量。    
所以，建议是：除非必须，不要使用递增递减的后置版本，它们生成了临时变量，是一种浪费。  


### 左值引用
左值引用就是引用左值的，是绑定到左值上的引用。c++11 之前，引用都是左值引用。左值引用就相当于给一个对象取一个别名。  

它与指针是有显著区别的，指针可以指向 NULL 对象，指针可以只声明不初始化，但左值引用都不行。左值引用必须引用一个已经存在的对象，必须定义时初始化，像这样:  

```c++
int i = 100;
int& refi = i;  // 可以
int& refi2;     // 不可以
```

另外，左值引用不能绑定到临时对象上：        

```c++
int& i = 100;           // 不可以
string& s {"hello"};    // 不可以
```

### const 引用
const 引用是一种特殊的左值引用，但比较特殊，它可以绑定到右值上，像下面这些都是合法的：  

```c++
const int& i1 = 100; // 合法，相当于这两个语句：int temp = 100; const int& i1 = temp;

const string& s1 {"hello"}; // 合法，相当于这两个语句：string temp {"hello"}; const string& s1 {temp};
```

c++ 只会为 const 引用产生临时对象，不会对非 const 引用产生临时对象。  


### 右值引用
右值引用是 c++11 引入的新概念，就是绑定到右值上的引用，用 `&&` 代表。   

怎么理解右值引用类型的形参本身是一个左值？怎么理解形参都是左值？


### 引用小结
总结起来，实际上应该是三种引用： 
* 左值引用
* const 引用（一种特殊的左值引用）
* 右值引用


### std::move 与移动语义

要注意，数据移动不是 std::move 的行为，std::move 只是做了一次类型转换，把左值类型强制转换为右值，真正完成数据移动的是移动构造函数。   

只有一个类没定义任何自己版本的拷贝构造函数、拷贝赋值运算符，析构函数，且类的每个非静态成员都可以移动时，编译器才会为该类合成移动构造函数或者移动赋值运算符。[1]可以移动的成员如下：  
1、内置类型（如整型、实型等）；
2、成员变量是一个类类型，且这个类有对应的移动操作相关的函数；  



参考：
《现代c++语言核心特性解析》https://weread.qq.com/web/reader/22d32dd0726fa07122d86dbk67c32d7022f67c6a1e7ce82?

---

## 返回值优化 RVO、NRVO
这是一种编译器优化


---

## 智能指针
指针太危险了，要写出安全的代码，我们必须花时间好好总结一下，有哪些特性可以帮助我们规避指针的危险。  

---

## const
const 在各个位置的意义？
成员函数末尾的 const
开头的 const

---

## const_expr

为何 const_expr 重要？ 

---

## 模板

---

## noexcept

---

# 常用优化手段

## Pimpl
Pimpl 惯用法通过降低类的客户和类实现者之间的依赖性，减少了构建的遍数。[2]  

## 减少临时对象
这是一个比较庞大的话题，前面介绍过的右值引用，移动语义，其目的都是为了减少临时对象。


---

# 内存安全的代码
TODO



---

# todo
* 简单的完善左值右值
* 搞清楚 c++ 的 const / const_expr
* 写一写智能指针
* 详细阅读《modern effective c++》条款7的列表初始化

---

# 总结
* c++ 太复杂了，好多人因为这个原因放弃了它，但依然很多人在使用它，说明它有独特的价值。   

* 在我看来，c++ 存在的价值在于弹性：它既有原始的部分，也有高级的部分；它能比其他语言让你更靠近机器去编程，去榨干机器的性能，也能让你在高一层的抽象维度去编程，忽略机器的细节。  

* c++ 的内存、指针都是危险的，所以我们很有必要花时间归纳总结如何写出安全的代码。  

* c++ 跟其他语言一样，完成一件事有好几种写法，但有些写法效率是很高的，所以我们也有必要花时间归纳总结如何写出高效的代码。  

* 要真正掌握 c++ 的精髓，必然是要了解它的底层实现（比如看透这本书《inside the c++ object model》），要能读懂一段代码翻译成汇编是什么样子的，是怎么工作起来的，了解了这些，也就差不多了解了计算机是怎么工作的。  

* 不清楚一个特性的时候先不要使用它，否则反而坑到自己，但也不要固步自封，要积极去学习和掌握 c++ 新版本的新特性，这些都可能带来生产力的提升。   



---

# 参考
[1] 王健伟. C++新经典. 北京: 清华大学出版社, 2020-08-01.   

[2] [美]Scott Meyers. Effective Modern C++(中文版). 高博. 北京: 中国电力出版社, 2018-4: 149.  

[3] [美] Stanley B. Lippman, Josée Lajoie, Barbara E. Moo. C++ Primer 中文版（第 5 版）. 王刚, 杨巨峰. 北京: 电子工业出版社, 2013-9: 120, 154, 182. 