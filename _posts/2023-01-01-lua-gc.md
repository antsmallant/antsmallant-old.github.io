---
layout: post
title: "lua gc 算法研究"
date: 2023-01-01
last_modified_at: 2023-01-01
categories: [lua]
tags: [lua gc 垃圾回收]
---

* 目录  
{:toc}
<br/>  


这是我研究 lua gc 算法的一篇笔记，虽然网上可以找到很多分析文章，但写下自己的理解是很有必要的。本文涉及的 lua 版本从 5.0 到 5.4，第一部分讲设计与实现，第二部分讲如何调优以减少 cpu 突刺。   

很多时候，想查证 lua 的一些细节，最快的方式不是在网上搜索别人的文章，而是自己去看它的源码，它的源码足够的简短小巧，阅读起来不费劲。当然，一开始总是有点难的，但积累一些经验之后就很通畅了。  

lua 所有版本的源码都可以在这里下载：https://lua.org/ftp/ 。

---

# 设计与实现
lua gc 一直使用标记清除算法（mark&sweep），随着版本的迭代，对这一算法逐步进行优化。各版本的情况大致如下：    

|版本|算法|备注|
|--|--|--|
|5.0|基本 mark&sweep|双色标记|
|5.1|增量式 mark&sweep|三色标记|
|5.2|增量式 mark&sweep + 分代式|引入分代式，实验性质的|
|5.3|增量式 mark&sweep|去掉分代式|
|5.4|增量式 mark&sweep + 分代式|再次引入分代式，比较成熟了|
   
lua5.4 的分代式 gc 表现不错，在 lua 可执行程序里，已经被设置为默认 gc 算法，而在 liblua.a 里默认 gc 算法还是增量式的。也就是说在命令行中直接运行的 lua 程序，用的是分代式 gc，把 lua 作为库链接到你的程序中，用的是增量式 gc。      


## 基本标记清除
算法很简单，就是从根集开始扫描，找出所有被根集直接或间接引用到的对象，被引用的对象标为黑色，没被引用的对象标为白色，标记完成后，清除掉所有白色对象。  

所谓根集，就是 lua 虚拟机使用的基础对象，这些对象从虚拟机诞生到销毁都始终存活着，虚拟机运行过程中产生的其他对象都直接或间接被这些基础对象引用到。根集包含这些对象：registry(global table, main thread, package.loaded), shared metatables。   

实现上，lua 用一个链表来保存所有这些 “可回收对象”。扫描结束的时候，只需要遍历这个链表，回收所有标为白色的对象。    


## 增量式标记清除
基本标记清除的特点是一轮 gc 过程只能原子执行，程序必须停止运行其他逻辑，等待 gc 完成。如果 gc 耗时过长，那么整个程序看起来就像失去了响应一样。  

特别是对于游戏服务器这种延迟敏感型的，后果特别严重，会导致明显的掉帧问题，即逻辑帧率不及预期。   

为了解决 stop the world 问题，从 lua5.1 开始就引入了增量 gc。它的核心目标就是避免一轮 gc 的时候 stop the world，核心做法就是把一轮 gc 拆成多个步骤。运行的时候是这样交替执行的：

```
gc-开始 | gc-step | 正常逻辑 | ... | gc-step | 正常逻辑 |...| gc-结束 |  
```

几乎每个版本都对增量式 gc 算法有所改进，每次改进可能会细化 gc 步骤，lua5.4 的 gc 步骤定义如下（取自 lgc.h ）：  

```
#define GCSpropagate	0
#define GCSenteratomic	1
#define GCSatomic	2
#define GCSswpallgc	3
#define GCSswpfinobj	4
#define GCSswptobefnz	5
#define GCSswpend	6
#define GCScallfin	7
#define GCSpause	8
```

下面以 lua5.4 为例详细讲一下 gc 的工作过程。  

首先说一下触发条件，lua 使用债务来描述内存占用，申请内存是负债，释放内存是还债，当债务达到某个值时，就会触发 gc。  

接着说一下各个 gc 步骤做的事情，gc 总体上可以分成3个阶段，如下。  

标记阶段：   
GCSpause
GCSpropagate   
GCSenteratomic   
GCSatomic

清除阶段：  
GCSswpallgc   
GCSswpfinobj   
GCSswptobefnz   
GCSswpend   

结束阶段：  
GCScallfin   


### 标记阶段
标记即染色，使用3种颜色来标记对象，分别是白、灰、黑，所以增量式标记清除也常被称为三色标记清除。   

但实际上，白里面还分了 current-white、other-white，current-white 表示本轮 gc 开始之后新建的对象，other-white 表示本轮之前的，在清除阶段，只会清除掉 other-white 的对象。  

标记阶段大致过程是这样的：    

一、GCSpause  

只能原子执行一次，调用一个叫 restartcollection 的函数对根集进行初步标记，根集即 mainthread、registry表、G表 这几个对象，对这几个对象直接引用的子对象进行 mark。mark 算法是这样的，下面不再赘述：如果子对象会引用其他对象，则标记为灰色，并加入 gray 链表；否则直接标记为黑色。 GCSpause 只执行一次。  

以下代码来自 lgc.c   

```
/*
** mark root set and reset all gray lists, to start a new collection
*/
static void restartcollection (global_State *g) {
  cleargraylists(g);
  markobject(g, g->mainthread);
  markvalue(g, &g->l_registry);
  markmt(g);
  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
}
```

二、GCSpropagate   

可以分散的执行 N 次，每次从 gray 链表中取一个对象出来，首先把这个对象标记为黑色，然后 mark 所有未 mark 过的子对象。GCSpropagate 会被执行 N 次，直到 gray 链表为空。  

由于 GCSpropagate 会与正常逻辑交替执行，那么会出现这样的情况：
1、被标为灰色或黑色的对象不再被引用了；  
2、被标为黑色的对象引用了白色对象；   

第1种情况可以不处理，它顶多导致本轮漏回收一些内存，我们可以在下一轮再回收。第2种情况必须处理，否则新的对象会由于没有标记到而被错误的回收。  

lua 使用写屏障 (write barrier) 来解决第2种情况，写屏障有两种做法，一种被称为 barrier forward，另一种是 barrier backward。两者的区别是，forward 是把新的白色对象 mark 为灰色并加入 gray 链表；而 backward 是把黑色对象改回灰色并加入 grayagain 列表，grayagain 链表会在标记阶段的末尾被一次性扫描。   

有趣的是，lua 同时使用了这两种做法，如果黑色对象是 table 类型的，则使用 barrier backward，否则使用 barrier forward。采用这种方式，应该是性能上的综合考量。  

三、GCSenteratomic 、GCSatomic    

GCSenteratomic 是一个过渡步骤，承上启下，起一个过渡作用。它会调用 atomic 函数执行 GCSatomic 阶段，之后调用 entersweep 开始进入清除阶段。  

GCSatomic 即是标记阶段的收尾，主要做以下的事情：   


### 清除阶段

一、GCSswpallgc   



二、GCSswpfinobj     


三、GCSswptobefnz   


四、GCSswpend    


### 结束阶段

一、GCScallfin   



## 分代式
分代 gc 可以认为是 mark&sweep 算法的一种优化策略。它的核心目标就是减少每轮 gc 需要扫描的对象个数，有些对象是长期存在的，没必要频繁去扫描。基本思路就是根据存活时间对这些对象分类，对于 “年老” 的对象，减少扫描次数，对于 “年轻” 的对象，多扫描。     

lua5.2 开始，就引入了分代式 gc，当时只是试验性质的，默认还是增量式。但是由于实现上不太成熟，实际运行效果不佳，在 5.3 版本被删掉了。到了 lua5.4，它又被重新实现出来。   
 

简单描述一下算法逻辑。   


这几篇文章比较详细地介绍了 lua5.4 的分代 gc 算法，可以参考一下：  
* [《Lua5.4 源码剖析——垃圾回收7 之 分代式算法 上》](https://zhuanlan.zhihu.com/p/601609031)
* [《Lua5.4 源码剖析——垃圾回收8 之 分代式算法 中》](https://zhuanlan.zhihu.com/p/605301309)
* [《Lua5.4 源码剖析——垃圾回收9 之 分代式算法 下》](https://zhuanlan.zhihu.com/p/608018655)

---

# 增量式与分代式对比
增量式有哪些不足之处？可以归结为三点：   
* 每个完整周期的总任务量都很大，对所有对象做了全量扫描；
* 及时性不足，对于新旧对象都一视同仁的处理；
* 性能消耗不会随着程序运行稳定而下降，即使长期存活的对象也是一再的被扫描，gc 可以说没有消停的时候；

而分代式可以说是把上面的3个缺点都克服了，是一种更理想的想法。但它是否也有缺点呢？

---

# 若干问题探究
## 增量式 gc 的参数


## 分代式 gc 的参数


## 弱表
弱表是 lua 的一种特性，为了支持这种特性，gc 算法也需要有相应的处理。同时，这种特性也带来了 gc 算法上的一些麻烦。   


## 蜉蝣表（瞬表）


## 析构


## 值对象与引用对象
lua 5.1 ~ 5.4，定义的类型有9种：  

```
#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8
```  

其中 LUA_TSTRING 之前的（LUA_TNIL、LUA_TBOOLEAN、LUA_TLIGHTUSERDATA、LUA_TNUMBER）都属于值类型，LUA_TSTRING 以及之后的都属于引用类型。  

值类型不需要被垃圾回收，作为参数传递的时候 “按值传递”，即函数中不会修改实参的值。引用类型则相反，需要垃圾回收，参数传递时是 “按引用传递”。   


## 短字符的 gc
lua5.1 的时候，所有的字符串不论大小都放在一个 hash table 里，即 global_State 的 strt 字段，创建字符串时，先从 hash table 查找，找不到再新建。  

lua5.2 开始，做了一点限制，只有长度（strlen）小于等于 40 的字符串才会放到 hash table 里。  

在同个虚拟机里相同短字符串肯定是同一个对象，直接比较地址就行了，所以短字符的比较效率特别高。   


## 基于寄存器的虚拟机
lua 的寄存器和栈是两个让人容易误解的称呼，与我们熟知的寄存器和栈有些差别。lua 虚拟机会维护一个数据栈，这个数据栈是一个 TValue 类型的数组，而寄存器实际上就是这个数组的索引。  

lua 虚拟机里面还有另一个栈，是一个 CallInfo 类型的数组。这个跟我们熟知的栈就比较类似了，CallInfo 记录的是函数调用信息，这个栈就是按调用层次顺序存储调用信息的。  

说回正题，我们知道目前 lua 是基于寄存器的虚拟机 (register-based vm)，与之相对的是基于栈的虚拟机(stack-based vm)。这两者有何区别？通常我们会看到这样的一个例子，对于这样一个运算 `c = a + b`，

如果是 stack-based vm，可能生成这样的指令：   

```
pushstack a 
pushstack b
call add
```

如果是 register-based vm，可能生成这样的指令：     

```
load a to r0
load b to r1
call add r0 r1 r2
```

区别在哪？stack-based vm 的 add 指令，并不需要关心操作数在哪里，设计上已经约定操作数就是 "栈顶" 和 "栈顶-1" 这两个位置。而 register-based vm 的 add 指令，需要指定操作数的位置，add r0 r1 r2 就表示要把 r0 位置跟 r1 位置的数相加并存到 r2 位置。  

通常的说法是 register-based vm 的效率更高。是这样吗？从上面的例子看，实现加法都使用了三条指令，并且 stack-based 看起来还更简单。   

寄存器的本意就是高速的缓存，这里也是类似意思。当某些操作数需要被频繁操作的时候，register-based 的优势就体现出来了。比如这样：   

```
c = a + b
d = h + b
e = i + b
```

这种情况，我们可以只 load 一次 b 到某个寄存器里，重复的使用它，不像 stack-based 需要反复的把它 pushstack，所以 register-based 在指令分派次数，内存访问次数上都要优于 stack-based。  

---

# 调参优化
普通的应用，不需要对 gc 参数进行调优的，使用默认的 gc 参数就够了。游戏服务器对于 cpu 突刺是很敏感的，很容易引起掉帧问题。所谓掉帧就是游戏服运行过程中每秒跑的逻辑帧数不及预期，比如本来设计是每秒 20 帧，结果由于 gc 消耗了过多的 cpu 时间，导致一秒跑不了 20 帧。    
todo   

---

# 拓展阅读
* codedump：[《Lua设计与实现》](https://github.com/lichuang/Lua-Source-Internal/tree/master/doc)
* 云风: [Lua GC 的源码剖析](https://blog.codingnow.com/2011/03/lua_gc_1)
* 云风: [Lua GC 的工作原理](https://blog.codingnow.com/2018/10/lua_gc.html)
* Roberto Ierusalimschy: [The Implementation of Lua 5](https://www.lua.org/doc/jucs05.pdf)
* Roberto Ierusalimschy: [Garbage Collection in Lua](https://www.lua.org/wshop18/Ierusalimschy.pdf)
* feileo: [GC 机制探究之 Python 篇](https://zhuanlan.zhihu.com/p/295062531)
* Dibyendu Majumdar: [Lua 5.3 Bytecode Reference](https://the-ravi-programming-language.readthedocs.io/en/latest/lua_bytecode_reference.html)
* Kein-Hong Man: [A No-Frills Introduction to Lua 5.1 VM Instructions](https://github.com/antsmallant/lua-docs/blob/main/A%20No-Frills%20Introduction%20to%20Lua%205.1%20VM%20Instructions.pdf)  


---

# 总结
* lua 的实现很紧凑，一条链表闯天涯。 