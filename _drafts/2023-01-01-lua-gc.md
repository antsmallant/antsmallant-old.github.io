---
layout: post
title: "lua gc 算法设计与实现"
date: 2023-01-01
last_modified_at: 2023-01-01
categories: [lua]
tags: [lua gc 垃圾回收]
---

* 目录  
{:toc}
<br/>  


本文将介绍 lua 的 gc 算法，包含 lua5.0 到 lua5.4。第一部分讲设计与实现，第二部分讲如何调优以减少 cpu 突刺。   

## 设计与实现
lua 的 gc 一直使用的是标记清除算法（mark and sweep），随着版本的迭代，对这一算法逐步进行优化。   

大体可以分为两个时期，第一个是 lua5.0 及之前的，都是采用 stop the world 式的双色标记清除法，lua5.1 及之后，主要采用了增量式的（即一轮 gc 拆分成多个阶段进行）。 two-color mark sweep 算法[1]；第二个是 lua5.1 及之后的。   

|版本|算法|特点|
|--|--|--|
|5.0|基本的 mark-sweep|双色标记，会 stop the world|
|5.1|增量式的 mark-sweep|三色标记，分多个阶段|
|5.2|增量式的 mark-sweep gc，分代 gc（实验性的）|
|5.3|增量式的 mark-sweep|三色标记，分多个阶段|
|5.4|增量式的 mark-sweep|三色标记|

### 基本标记清除
算法很简单，就是从根集开始扫描，找出所有被根集直接或间接引用到的对象，然后把不再被引用的对象都回收掉。  
所谓根集，就是 lua 虚拟机使用的基础对象，这些对象从虚拟机诞生到销毁都始终存活着，虚拟机运行过程中产生的其他对象都直接或间接被这些基础对象引用到。根集包含这些对象：global_state，注册表（包含 mainthread）。

### 增量式标记清除
双色标记法的特点是一轮 gc 过程只能原子执行，这时程序必须停止运行其他逻辑，等待 gc 完成。如果 gc 的耗时过长，那么整个程序看起来就像失去了响应一样。特别是，对于游戏服务器这种延迟敏感型的，后果特别严重，会导致明显的掉帧问题（即逻辑帧率不及预期）。  

为了解决 stop the world 问题，从 lua5.1 开始就引入了增量 gc。它的核心目标就是避免一轮 gc 的时候 stop the world，核心做法就是把 gc 过程拆成多个步骤。运行的时候就是这个样子:   
...|gc步骤1(一轮gc开始)|正常逻辑|gc步骤2|正常逻辑|...|gc步骤n（一轮gc结束）|...  

由于 gc 与正常逻辑交织在一起运行，那么就会出现这样的情况：  
1、原先标为黑色的，增加了新的引用；   
2、原先标为黑色的，运行过程中其实没人引用了； 

要解决这样的问题，就引入了写屏障。写屏障有两种做法，第一种被称为 barrier forward，

### 分代式
分代 gc 的核心目标就是减少每轮 gc 需要扫描的对象个数，有些对象它就是长期存在的，每次都去扫描是一种浪费。最朴素的想法就是把这些对象分一些类，存活时间已经比较长的归为一类，存活时间比较短的归为另一类，存活时间长的说明它可能会长期存在，可以减少扫描的次数，存活时间短的说明它可能不久后就需要被回收，那就频繁的扫描它。   

lua 从 5.2 开始，就引入了分代式 gc 作为试验性的特性，默认还是增量式的，不过可以通过调用 collectgarbage("generational") 切换为分代式的。但是实现上不太成熟，实际运行效果不好，所以在 5.3 版本直接就被屏蔽掉了。到了 lua5.4，它又卷土重来，在 lua



### 若干问题探究
#### 弱表
弱表是 lua 的一种特性，为了支持这种特性，gc 算法也需要有相应的处理。同时，这种特性也带来了 gc 算法上的一些麻烦。  



#### 蜉蝣表（瞬表）
某些特殊的弱表会带来 “循环引用” 的问题。

#### 析构

#### 值对象与引用对象

#### 基于寄存器的虚拟机？
lua 的寄存器和栈是两个极其让人容易误解的称呼，与我们平时讲的寄存器和栈完全是两码事。首先寄存器，根本不是我们熟知的 cpu 上的寄存器，它本质上就是一个 c 数组，寄存器指的就是数组上一个个元素。是个很容易让人混淆的概念，它根本就是我们熟知的 cpu 里的寄存器，而是一种模拟出来的寄存器。在实现上，它就是一个数组。


## 调参优化
对于普通的应用，是不需要对 gc 参数进行调优的，默认的参数已经足够好了。  
游戏服务器对于 cpu 突刺是很敏感的，它很容易引起掉帧问题。所谓掉帧就是游戏服运行过程中每秒跑的逻辑帧数不及预期，比如本来设计是每秒20帧，结果由于 gc 消耗了过多的 cpu 时间，导致一秒跑不了 20 帧。  

优化的思路

## 拓展阅读
[1] codedump, "Lua设计与实现", 人民邮电出版社  
[2] 云风, "Lua GC 的源码剖析" 系列文章, https://blog.codingnow.com/2011/03/lua_gc_1.html  
[3], Roberto Ierusalimschy, "The Implementation of Lua 5"
[4], feileo, "GC 机制探究之 Python 篇", https://zhuanlan.zhihu.com/p/295062531


## 总结


## 参考文献
