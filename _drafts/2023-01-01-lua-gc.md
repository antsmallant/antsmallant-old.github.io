---
layout: post
title: "lua gc 算法"
date: 2023-01-01
last_modified_at: 2023-01-01
categories: [lua]
tags: [lua gc 垃圾回收]
---

* 目录  
{:toc}
<br/>  


本文是我研究 lua gc 算法的一篇笔记。网上可以找到很多分析 lua gc 算法的文章，但用自己的语言描述这部分知识还是很有意义的。  

内容上，主要介绍 lua 的 gc 算法，版本涵盖 lua5.0 到 lua5.4。第一部分讲设计与实现，第二部分讲如何调优以减少 cpu 突刺。   


## 设计与实现
lua 的 gc 一直使用的是标记清除算法（mark and sweep），随着版本的迭代，对这一算法逐步进行优化。各版本的 gc 算法大致如下。  

|版本|算法|特点|
|--|--|--|
|5.0|基本的 mark-sweep|双色标记，会 stop the world|
|5.1|增量式的 mark-sweep|三色标记，分多个阶段|
|5.2|增量式的 mark-sweep，分代式|分代式是试验性的|
|5.3|增量式的 mark-sweep|三色标记，分多个阶段|
|5.4|增量式的 mark-sweep，分代式|三色标记|


### 基本标记清除
算法很简单，就是从根集开始扫描，找出所有被根集直接或间接引用到的对象，然后把不再被引用的对象都回收掉。  

所谓根集，就是 lua 虚拟机使用的基础对象，这些对象从虚拟机诞生到销毁都始终存活着，虚拟机运行过程中产生的其他对象都直接或间接被这些基础对象引用到。根集包含这些对象：registry(global table, main thread, package.loaded), shared metatables。   

原理很简单，就是双色标记，有被引用到的标为黑色，没被引用到的标为白色，标记完成后，清除掉所有白色的对象。  

实现上，lua 用了一个链表来保存所有这些“可回收对象”。  


### 增量式标记清除
双色标记法的特点是一轮 gc 过程只能原子执行，这时程序必须停止运行其他逻辑，等待 gc 完成。如果 gc 的耗时过长，那么整个程序看起来就像失去了响应一样。特别是，对于游戏服务器这种延迟敏感型的，后果特别严重，会导致明显的掉帧问题（即逻辑帧率不及预期）。  

为了解决 stop the world 问题，从 lua5.1 开始就引入了增量 gc。它的核心目标就是避免一轮 gc 的时候 stop the world，核心做法就是把 gc 过程拆成多个步骤。运行的时候就是这个样子:   
...|gc步骤1(一轮gc开始)|正常逻辑|gc步骤2|正常逻辑|...|gc步骤n（一轮gc结束）|...  

由于 gc 与正常逻辑交织在一起运行，那么就会出现这样的情况：  
1、原先标为黑色的，增加了新的引用；   
2、原先标为黑色的，运行过程中其实没人引用了； 

要解决这样的问题，就引入了写屏障（write barrier）。写屏障有两种做法，一种被称为 barrier forward，另一种是 barrier back。  

两者的区别是，当一个白色对象被一个黑色对象引用时，barrier forward 是直接把这个白色对象变更为灰色对象，让它去等待扫描，而 barrier backward 是把这个黑色对象改回灰色对象并加入 grayagain 列表，让它等待重新被扫描。

lua 同时使用了这两种 barrier，如果黑色对象的类型是 table，则使用 barrier backward，否则使用 barrier forward。lua 采用这种方式，应该是性能上的综合考量。并且，上面提到的 grayagain 列表，是在扫描阶段最后的一次性扫描中进行的，这样可以避免反复的对一个有元素变化的 table 执行扫描。  




### 分代式
分代 gc 的核心目标就是减少每轮 gc 需要扫描的对象个数，有些对象它就是长期存在的，每次都去扫描是一种浪费。最朴素的想法就是根据存活时间对这些对象分类，对于“年老”的对象，减少扫描次数。   

lua 从 5.2 开始，就引入了分代式 gc 作为试验特性，默认还是增量式的，不过可以通过调用 collectgarbage("generational") 切换 gc 为分代式。但是由于实现上不太成熟，实际运行效果不好，所以在 5.3 版本直接就被屏蔽掉了。到了 lua5.4，它又卷土重来。   

这篇文章 [《Lua5.4 源码剖析——垃圾回收8 之 分代式算法 中》](https://zhuanlan.zhihu.com/p/605301309) 比较详细介绍了 lua5.4 的分代 gc 算法。下面简要描述一下算法过程。  





### 若干问题探究
#### gc的触发时机：债务管理
#### 弱表
弱表是 lua 的一种特性，为了支持这种特性，gc 算法也需要有相应的处理。同时，这种特性也带来了 gc 算法上的一些麻烦。  



#### 蜉蝣表（瞬表）
某些特殊的弱表会带来 “循环引用” 的问题。

#### 析构

#### 值对象与引用对象


#### 基于寄存器的虚拟机？
lua 的寄存器和栈是两个极其让人容易误解的称呼，与我们平时讲的寄存器和栈完全是两码事。首先寄存器，根本不是我们熟知的 cpu 上的寄存器，它本质上就是一个 c 数组，寄存器指的就是数组上一个个元素。是个很容易让人混淆的概念，它根本就是我们熟知的 cpu 里的寄存器，而是一种模拟出来的寄存器。在实现上，它就是一个数组。


## 调参优化
对于普通的应用，是不需要对 gc 参数进行调优的，默认的参数已经足够好了。  
游戏服务器对于 cpu 突刺是很敏感的，它很容易引起掉帧问题。所谓掉帧就是游戏服运行过程中每秒跑的逻辑帧数不及预期，比如本来设计是每秒20帧，结果由于 gc 消耗了过多的 cpu 时间，导致一秒跑不了 20 帧。  


## 拓展阅读
[1]codedump. Lua设计与实现. 人民邮电出版社. 2017.08.
[2]云风. Lua GC 的源码剖析.https://blog.codingnow.com/2011/03/lua_gc_1.2011.03.
[3]Roberto Ierusalimschy, et al. The Implementation of Lua 5.
[4]Roberto Ierusalimschy. Garbage Collection in Lua. https://www.lua.org/wshop18/Ierusalimschy.pdf.
[5]feileo. GC 机制探究之 Python 篇. https://zhuanlan.zhihu.com/p/295062531. 2023.06.


## 总结


## 参考文献
