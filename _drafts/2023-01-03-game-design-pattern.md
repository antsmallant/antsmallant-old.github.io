---
layout: post
title: "游戏开发之设计模式"
date: 2024-01-05
last_modified_at: 2024-01-05
categories: [游戏开发]
tags: []
---

* 目录  
{:toc}
<br/>

游戏开发是一个快速迭代的过程，代码复杂度也很高，借助于设计模式，可以帮助我们降低复杂度，降低系统间的耦合。  

本文将介绍游戏中使用频率高的一些设计模式。  

---

# 单例模式
使用频率：五颗星。  
是否推荐：否。    

随便问十个人，最熟悉的设计模式是什么，估计有八个人会脱口而出单例模式。  

尽管这个模式出现在了 GoF 的书中，但是它弊大于利，并不是一个好的模式。因为它制造了全局变量，而全局变量是有害的。  

《游戏编程模式》对此提出了批评[1]：
* 它是一个全局变量，它们令代码晦涩难懂，全局变量促进了耦合，它对并发不友好。  
* 它是个画蛇添足的解决方案，比如把 Log 类做成单例，当到处都有 log 写入，log 文件变成垃圾场时，我们又需要把 Log 改为多实例的，但此时修改起来已经特别麻烦了。  
* 延迟初始化剥离了你的控制，实际上游戏开发中并不需要延迟初始化，反而是在一开始就做好了初始化，避免运行过程中初始化带来卡顿。  

针对单例模式的两大特性：1）限制全局单一实例；2）便于访问，书中[1]也给出了单例的替代方案：  
* 将类限制为单一实例，可以实现单例模式的单例特性，比如这样： 
    ```
    class FileSystem
    {
    public:
      FileSystem()
      {
        assert(! instantiated_);
        instantiated_ = true;
      }

      ～FileSystem() { instantiated_ = false; }

    private:
      static bool instantiated_;
    };

    bool FileSystem::instantiated_ = false;
    ```
* 为实例提供便捷的访问方式，可以实现单例模式便于访问的特性，比如这样：   
    * 把对象作为参数传递进去；  
    * 在基类中获取它，比如把 Log 作为基类的内部对象，那么相应的继承类都可以获得访问这个 Log 对象；
    * 通过其他全局对象访问它，这是一种折衷的策略，通过减少全局变量来减少耦合，但也不失为一种好的做法，比如游戏开发中，我们始终会有一个变量来表示整个游戏或整个世界的 world 对象，那么我们可以把那些单例实例都放到这个 world 对象里面，最终我们只通过 world 对象去访问它们。  
    * 通过服务定位器来访问。 

对于有静态变量的编译型语言如 C++，实现 “将类限制为单一实例” 是容易的，但是像 lua 这种动态语言，要如何实现这种特性呢？  

---

# 观察者模式
使用频率：五颗星。  
是否推荐：是。  

GOF 对它意图的定义是： “定义对象间的一种一对多的依赖关系，当一个对象的状态发生状态时，所有依赖于它的对象都得到通知并被自动更新”[2]。  

---







并给出了替代方案：  
* 

---

# todo
* AOP 的实例
* lua 相关的设计模式
* 云风关于 lua 设计模式的表述

---

# 总结


---

# 参考
[1] [美]Robert Nystrom. 游戏编程模式[M]. GPP翻译组. 北京: 人民邮电出版社, 2016-09-01: 61.   

[2] [美]Erich Gramma, Richard Helm, Ralph Johnson, John Vlissides. 设计模式: 可复用面向对象软件的基础[M]. 李英军, 马晓星, 蔡敏, 刘建中, 等. 北京: 机械工业出版社, 2010(1)：194.     
