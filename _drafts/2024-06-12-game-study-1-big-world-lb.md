---
layout: post
title: "游戏服务器研究一：大世界的 scale"
date: 2024-06-12
last_modified_at: 2024-06-12
categories: [游戏后端]
tags: [gameserver]
---

* 目录  
{:toc}
<br/>

这篇文章不敢冠以 “工程实践” 之名，因为纯属研究性质的东西，属于对学习到的知识的一种总结，不敢误人子弟。  

本文讨论的内容，可以说是游戏服务器最难的问题之一：如何对大世界进行 scale。  

分区分服类型的游戏，本人只做过 mmo 的，并且不是单服人数特别夸张的 mmo，能支持到的同屏人数就是 200 人而已（我跟前端主程花了一周多时间老板说这样就够了）。  

---

# scale

## 第一代 scale 技术

大地图分成多个小地图，每个小地图放到一个单独的逻辑单元（node）去跑（进程或线程），这种情况要处理的主要就是边界的问题，node1，node2 这两个相邻的 node，node1的上玩家 node1p 走到 node1 的边界，要能看到边界上 node2 的玩家 node2p，

这里的问题在于，当人群聚集在特定小地图上的时候，小地图的负载会很重，照样会出现卡的问题。  

并且，更糟糕的事，如果人群是聚集在 node 的边界进行战斗，那么两个 node 的压力都很大。  

这篇文章 [《游戏服务端高性能框架：来看《天谕》手游千人团战实例》](https://zhuanlan.zhihu.com/p/700231330) 换了一种思路，不切分地图，而是通过纵向拆分，提升单线程处理主逻辑的能力，最终用 60%~80% （主线程40%~50%，网络线程20%~30%）的单进程 cpu 消耗，支撑 1150+人 在同一地图团战。  

---


## 第二代 scale 技术

bigworld 的分布式 aoi

kbenginge 实现到什么程度？ kbengine 的 space 是什么东西？

---

# 夹带一些其他问题

## 相位技术

魔兽的相位技术的实现，云风的这篇文章 [《相位技术的实现》](https://blog.codingnow.com/2012/11/phasing_technology.html) [1]考虑了一种可行的实现。  

本质上还是同一张地图拆分成多个场景服务去处理，这些场景都用同一张地图，但是上面布置的 npc 不一样，通过把玩家 agent 放到不同的场景服务来切换它的可见物。这种方式用他的 skynet 引擎去处理很简单，比在 C++ 里用多个线程去负载多个不同的场景简单得多，在 skynet 里，一切都是 actor，一个场景服务就是一个 actor（serivice），把一个玩家从一个 service 放到另一个 service，实现上很简单，性能上很快。  

---

# 参考

[1] 云风. 相位技术的实现. Avilable at https://blog.codingnow.com/2012/11/phasing_technology.html, 2012-11-23.   

[2] 